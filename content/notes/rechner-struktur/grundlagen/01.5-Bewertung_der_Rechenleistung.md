---
# Basic info
title: "Bewertung der Rechenleistung"
date: 2020-07-08
draft: false
type: docs # page type
authors: ["admin"]
tags: ["Vorlesung", "Zusammenfassung", "Rechnerstruktur"]
categories: ["Computer Structure"]
toc: true # Show table of contents?

# Advanced settings
profile: false  # Show author profile?

reading_time: true # Show estimated reading time?
summary: ""
share: false  # Show social sharing links?
featured: true

comments: false  # Show comments?
disable_comment: true
commentable: false  # Allow visitors to comment? Supported by the Page, Post, and Docs content types.

editable: false  # Allow visitors to edit the page? Supported by the Page, Post, and Docs content types.

# Optional header image (relative to `static/img/` folder).
header:
  caption: ""
  image: ""

# Menu
menu: 
    rechner-struktur:
        parent: grundlagen
        weight: 3

# Prev/next pager order (if `docs_section_pager` enabled in `params.toml`)
weight: 12
---


ğŸ¯ Ziel

- Auswahl der Rechenanlage
- VerÃ¤nderung der Konfiguration einer bestehenden Anlage
- Entwurf von Anlagen



## Bewertung der LeistungsfaÌˆhigkeit

Was heiÃŸt es: Ein Rechner ist **schneller** als ein anderer Rechner?

- Perspektive des Benutzers

  - â€Ein Rechner A ist schneller als ein Rechner B, wenn ein Programm auf A weniger Zeit benoÌˆtigt.â€œ

  - Reduzierung der Antwortzeit (response time) oder AusfuÌˆhrungszeit (execution time), Latenz
  - A ist $n$-mal schneller als B $\Leftrightarrow$ $\frac{\text { AusfÃ¼ncungszeit }(\mathrm{B})}{\text { AusfÃ¼nrungszeit }(\mathrm{A})}=\mathrm{n}$

- Perspektive des Rechenzentrumsleiters

  - â€Ein Rechner A ist schneller als ein Rechner B, wenn A in einer Stunde mehr AuftraÌˆge (Jobs) erledigt.â€œ

  - ErhoÌˆhung des **Durchsatzes (throughput)**

    - **Durchsatzes (throughput)**: Anzahl der ausgefuÌˆhrten Aufgaben in einem gegebenen Zeitintervall

    - Durchsatz von A ist m-mal hoÌˆher als der von B:

      $\Leftrightarrow$ Die Anzahl der erledigten Aufgaben auf A ist m-mal die Anzahl der erledigten Aufgaben auf B.

### Definitionen

- **AusfuÌˆhrungszeit (execution time)**
- **Wall-clock time, response time, elapsed time**
  - Latenzzeit fuÌˆr die AusfuÌˆhrung einer Aufgabe

  - SchlieÃŸt den Speicher- und Plattenzugriff, Ein-/ Ausgabe etc. mit ein.
- **CPU Time**: Zeit, in der die CPU arbeitet
  - **User CPU Time**: Zeit, in der die CPU ein Programm ausfuÌˆhrt
  - **System CPU Time**: Zeit, in der die CPU Betriebssystemaufgaben ausfuÌˆhrt, die von einem Programm angefordert werden

### Verfahren

#### Auswertung von HardwaremaÃŸen und Parametern

Der Rechner laÌˆuft mit **fester** Taktrate, angegeben durch 

- Dauer eines Taktzyklus (z. B. 1ns)

- Taktfrequenz (z. B. 1 GHz)

Die CPU-Zeit einer ProgrammausfuÌˆhrung:
$$
\mathrm{T}_{\mathrm{exe}}=\mathrm{IC} \times \mathrm{CPI} \times \mathrm{TC}
$$

- $\mathrm{T}_{\mathrm{exe}}$: CPU-Zeit

- $\text{IC}$: Instruction Count (Anzahl der ausgefuÌˆhrten Befehle)

- $\text{CPI}$: Cycles Per Instruction (Anzahl der Zyklen pro Instruktion)

  - Direkte AbschaÌˆtzung schwierig wegen der KomplexitaÌˆt heutiger Prozessoren und der Cache-Hierarchie

  - HaÌˆngt vom Kontext ab, in der eine Instruktion ausgefuÌˆhrt wird

  - Instructions Per Cycle:
    $$
    \mathrm{IPC}=1 / \mathrm{CPI}
    $$

- $\text{TC}$: Machine cycle time (Zykluszeit)

MaÃŸzahlen fuÌˆr die Operationsgeschwindigkeit

- **MIPS** (**M**illions of **I**nstructions **P**er **S**econd):
  $$
  \mathrm{MIPS}=\frac{\text { Anzahl der ausgefÃ¼hrten Instruktionen }}{10^{6} \times \text { AusfÃ¼hrungszeit }}
  $$

- **MFLOPS** (Millions of Floatingpointoperations Per Second)
  $$
  \text{MFLOPS} =\frac{\text { Anzahl der ausgefuhrten Gleitkommaoperationen }}{10^{6} \times \text { AusfÃ¼hrungszeit }}
  $$

ğŸ”´ **Probleme**

- AbhaÌˆngigkeit von ISA und ausgefuÌˆhrter Befehlssequenz
  - ISA = Instruction Set Architecture
- Unterschiedliche MIPS/MFLOPS-Zahlen bei verschiedenen Programmen
- MIPS kann umgekehrt zur tatsaÌˆchlichen Rechenleistung variieren
- MIPS/MFLOPS Angaben von Herstellern oft nur best-case-Annahme: theoretische Maximalleistung

##### ğŸ“ƒ Zusammenfassung

- Vergleich von Rechnern bezuÌˆglich ihrer Leistung ohne groÃŸen Aufwand 
- MaÃŸzahlen bewerten nur spezielle Aspekte

- Kritische Betrachtung der Leistungsangabe unbedingt notwendig! 
- Angabe einer hypothetische Maximalleistung!

#### Laufzeitmessungen bestehender Programme 

**Benchmarks**: Bewertung der LeistungsfaÌˆhigkeit aufgrund von Messungen mit Hilfe von einem Programm oder einer Programmsammlung

- Programme liegen im Quellcode vor
- Messung der AusfuÌˆhrungszeiten
- Zugriff auf die Maschinen notwendig

**Standardisierte Benchmarks**

- ğŸ¯ Ziel: Vergleichbarkeit von Rechnern (inkl. Betriebssystem und Compiler)
- Anforderungen:
  - Gute Portierbarkeit

  - RepraÌˆsentativ fuÌˆr typische Nutzung der Rechner
- Sammlung von Benchmark-Programmen (Benchmark Suites)
  - Ausgeglichene Bewertung durch die *unterschiedlichen Eigenschaften* der Programme
- Standardisierungsorganisationen
  - **TPC** (Transaction Processing Performance Council)
  - **SPEC** (Standard Performance Evaluation Corporation)

#### Messungen waÌˆhrend des Betriebs von Anlagen 

**Monitore**: Aufzeichnungselemente, die zum Zweck der Rechnerbewertung die VerkehrsverhaÌˆltnisse waÌˆhrend des normalen Betriebs beobachten und untersuchen.

- **Hardware-Monitore**
  - UnabhaÌˆngige physikalische GeraÌˆte 
  - Keine Beeinflussung
- **Software-Monitore**
  - Einbau in das Betriebssystem

  - BeeintraÌˆchtigung der normalen BetriebsverhaÌˆltnisse ğŸ¤ª

Aufzeichnungstechniken:

- Kontinuierlich oder sporadisch
- Gesamtdatenaufzeichnung (Tracing) 
- Realzeitauswertung

- UnabhaÌˆngiger Auswertungslauf (Post Processing)

#### Modelltheoretische Verfahren

UnabhaÌˆngig von der Existenz eines Rechners

**Modellbildung**

- ğŸ¯ Ziel: 
  - Aufdecken von Beziehungen zwischen Systemparametern
  - Ermitteln von LeistungsgroÌˆÃŸen

1. Annahmen uÌˆber die Struktur und Betrieb eines Rechners und uÌˆber die Prozesse
2. Darstellung der fuÌˆr die Analyse relevanten Merkmale des Systems
   - Systemkomponenten
   - Datenverkehr zwischen den Systemkomponenten

3. Abstrahierung komplexer Systeme
   - Nur die interessierenden GroÌˆÃŸen werden erfasst

**Analytische Methoden**

- versuchen auf *mathematischem* Weg, Beziehungen zwischen relevanten LeistungskenngroÌˆÃŸen und fundamentalen Systemparametern herzuleiten

- oft nur minimaler Aufwand, aber dafuÌˆr weniger aussagekraÌˆftig ğŸ¤ª

- Typ

  - Warteschlangenmodelle

    ![æˆªå±2020-06-18 12.07.48.png](https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-18%2012.07.48-20200708102951085.png)

    Gesetz von Little:
    $$
    k = \lambda \cdot t
    $$

    $$
    Q = \lambda \cdot w
    $$

    - $k$: mittlere Anzahl der AuftraÌˆge
    - $\lambda$: Durchsatz (mittlere Anzahl von AuftraÌˆgen, die pro Zeiteinheit bedient werden)
    - $t$: Antwortzeit (Verweilzeit, Gesamtheit der Zeit, die ein Auftrag im Wartesystem verbringt)
    - $Q$: mittlere WarteschlangenlaÌˆnge
    - $w$: Wartezeit (Zeit, die angibt, die ein System im Wartesystem verbringt)
    - â€¼ï¸ Voraussetzung: **statistisches Gleichgewicht**
      - Die Rate, mit der die AuftraÌˆge ankommen = der Rate, mit der die AuftraÌˆge abgehen

  - Petrinetze

  - Diagnosegraphen

  - Netzwerkflussmodelle

**Simulation**

- Wieso brauchen wir Simulation?
  - Steigende KomplexitaÌˆt der Computer Systeme
  - Zentrales Werkzeug fuÌˆr den Rechnerarchitekt 
    - Evaluation neuer Ideen

    - Exploration des Entwurfsraums
  - BezuÌˆglich Hardware-Prototypen und analytischen Modellen
  - Quantifizierung einer Metrik bei der AusfuÌˆhrung einer Arbeitslast (Workload)
  - Workload Characterization:
    - Verstehen der GruÌˆnde fuÌˆr das beobachtete Verhalten

    - Verstehen des Zusammenspiels zwischen der Arbeitslast und dem Zielsystem

- Simulatoren

  - Ein Simulator modelliert die wesentlichen Eigenschaften oder das Verhalten einer Zielmaschine

  - Verschiedene Ebenen bezuÌˆglich der Details und der Genauigkeit

  - Benchmarks

    - Bewertung einer oder mehrerer Komponenten einer Zielmaschine 
    - Vergleich von verschiedenen Architekturen oder Architekturmerkmalen

  - Entwurf und Einsatz: *Kompromiss* zwischen hoher Simulationsgenauigkeit, hoher Simulationsgeschwindigkeit, und niedrigen Entwicklungsaufwand

  - Taxonomie

    - **User-Level** Simulatoren

      - Simulation der Mikroarchitektur eines Prozessors 
      - KEINE BeruÌˆcksichtigung von Systemressourcen

      <img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-18%2012.27.16.png" alt="æˆªå±2020-06-18 12.27.16" style="zoom:80%;" />

    - **Full-System** Simulatoren

      - Modellieren ein *vollstaÌˆndiges* Computersystem, einschlieÃŸlich CPU, I/O, Disk, Netzwerk
      - Booten und AusfuÌˆhrung von Betriebssystemen 
      - Beobachten der Interaktion von Workload und System

      <img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-18%2012.28.11.png" alt="æˆªå±2020-06-18 12.28.11" style="zoom:80%;" />

    - **Funktionale** Simulatoren (Functional Simulators)

      - Modelliert nur die FunktionalitaÌˆt (ohne BeruÌˆcksichtigung der Mikroarchitektur eines Prozessors)
      - Emulation der Befehlssatzarchitektur

      - Bildet oft den Ausgangspunkt einer komplexeren Simulationsumgebung

      <img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-18%2012.37.47.png" alt="æˆªå±2020-06-18 12.37.47" style="zoom:80%;" />

    - **Zyklen genaue** Simulatoren (Cycle-accurate Simulators)

      - Erfassen die Details der MikroarchitekturbloÌˆcke
      - Emulation der FunktionalitaÌˆt der MikroarchitekturbloÌˆcke sowie des Zeitverhaltens
      - MikroarchitekturbloÌˆcke sind parametrisierbar

      ![æˆªå±2020-06-18 12.41.11](https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-18%2012.41.11.png)

    - **Prozessor**simulator 

      - simuliert die AusfuÌˆhrung der Befehle eines Benchmarks auf einem Zielprozessor
      - Befehl erhalten
        - **Spurgetriebene** Simulatoren (trace-driven simulation)
          - AusfuÌˆhrung des Benchmarks auf einem ISA-kompatiblen Prozessor, oder einem Simulator (nicht notwendigerweise auf dem selben Prozessor wie dem Zielprozessor)
          - **WaÌˆhrend der AusfuÌˆhrung des Benchmarks werden die ausgefuÌˆhrten Befehle auf eine Spurdatei (Trace) geschrieben bzw. protokolliert**
          - Nach der Aufzeichnung dient die Spurdatei als Eingabe fuÌˆr einen Zyklen genauen Simulator
          - Jede Instruktion wird simuliert auf der Basis des Mikroarchitekturmodells
        - **AusfuÌˆhrungsgetriebene** Simulatoren (execution driven simulation)
          - Die ausfuÌˆhrbare Datei des Benchmark dient als Eingabe fuÌˆr den Simulator 
          - Simulator muss das Zeitverhalten sowie die FunktionalitaÌˆt genau reproduzieren
          - Aufwendige Entwicklung

          - Genauigkeit und FlexibilitaÌˆt besser als bei Spurgetriebenen Simulatoren