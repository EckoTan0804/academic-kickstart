---
# Basic info
title: "Superskalar"
date: 2020-07-08
draft: false
type: docs # page type
authors: ["admin"]
tags: ["Vorlesung", "Zusammenfassung", "Rechnerstruktur"]
categories: ["Computer Structure"]
toc: true # Show table of contents?

# Advanced settings
profile: false  # Show author profile?

reading_time: true # Show estimated reading time?
summary: ""
share: false  # Show social sharing links?
featured: true
lastmod: true

comments: false  # Show comments?
disable_comment: true
commentable: false  # Allow visitors to comment? Supported by the Page, Post, and Docs content types.

editable: false  # Allow visitors to edit the page? Supported by the Page, Post, and Docs content types.

# Optional header image (relative to `static/img/` folder).
header:
  caption: ""
  image: ""

# Menu
menu: 
    rechner-struktur:
        parent: prozessor-techniken
        weight: 3

# Prev/next pager order (if `docs_section_pager` enabled in `params.toml`)
weight: 22
---

## TL;DR

- Dynamische Parallelisierung eines sequentiellen Befehlsstroms
- Pro Takt werden **ein oder mehrere Befehle** aus dem Programmspeicher geholt und dekodiert
- Pro Takt kÃ¶nnen **mehrere Befehle** den AusfÃ¼hrungseinheiten zugewiesen werden
- **KonfliktauflÃ¶sung:** Parallele AusfÃ¼hrbarkeit der Befehle wird durch die Hardware ermittelt

- **Dynamisches Konzept**

- Weit verbreitet

- **Sequentielles Erscheinungsbild**
- 5 Phasen:
  - **Dekodierung**
  - **Registerumbenennung**
  - **Befehlszuordnung** (Issue + Dispatch)
  - **AusfÃ¼hrung**
  - **RÃ¼ckordnung**

## **RISC $\rightarrow$ Superskalar**

- Mehrfachzuweisungsmethoden (multiple issue)
  - Pro Takt mehrere Befehle den AusfuÌˆhrungseinheiten zuzuordnen und eine gleiche Anzahl von BefehlsausfuÌˆhrungen pro Takt zu beenden.
- Superskalare RISC-Prozessoren
  - RISC-Charakteristika werden auch heute noch weitgehend beibehalten
    - Lade-/Speicher-Architektur
    - Festes Befehlsformat *(z. B.: BefehlslaÌˆnge: 32 Bit)*
  - ğŸ¯ Entwurfsziel: **ErhoÌˆhung des IPC (Instruction per Cycle)**

## Superskalarer Prozessor

> A **superscalar processor** is a [CPU](https://en.wikipedia.org/wiki/Central_processing_unit) that implements a form of [parallelism](https://en.wikipedia.org/wiki/Parallel_computer) called [instruction-level parallelism](https://en.wikipedia.org/wiki/Instruction-level_parallelism) within a single processor. In contrast to a [scalar processor](https://en.wikipedia.org/wiki/Scalar_processor) that can execute at most one single instruction per clock cycle, a superscalar processor can execute more than one instruction during a clock cycle by simultaneously dispatching multiple instructions to different [execution units](https://en.wikipedia.org/wiki/Execution_unit) on the processor. It therefore allows for more [throughput](https://en.wikipedia.org/wiki/Throughput) (the number of instructions that can be executed in a unit of time) than would otherwise be possible at a given [clock rate](https://en.wikipedia.org/wiki/Clock_rate). Each execution unit is not a separate processor (or a core if the processor is a [multi-core processor](https://en.wikipedia.org/wiki/Multi-core_processor)), but an execution resource within a single CPU such as an [arithmetic logic unit](https://en.wikipedia.org/wiki/Arithmetic_logic_unit).
>
> More see: [Superscalar Processor](https://en.wikipedia.org/wiki/Superscalar_processor)

- NuÌˆtzt den **Parallelismus auf Befehlsebene** aus

  - Vielstufige Befehlspipeline 
  - Superskalartechnik

- **Eigenschaften**

  - Mehrere *voneinander unabhaÌˆngige* AusfuÌˆhrungseinheiten

  - Zur Laufzeit werden pro Takt mehrere Befehle aus einem sequentiellen Befehlsstrom den Verarbeitungseinheiten zugeordnet und ausgefuÌˆhrt

  - Dynamische Erkennung und AufloÌˆsung von Konflikten zwischen Befehlen im Befehlsstrom ist Aufgabe der Hardware

- **Struktur**

  <img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-28%2013.07.17.png" alt="æˆªå±2020-06-28 13.07.17" style="zoom:80%;" />

  - **Befehlsholeinheit** (Instruction Fetch)

  - **Dekodiereinheit** (Instruction Decode) mit **Registerumbenennung** (register renaming)

  - **Zuordnungseinheit** (Instruction Issue)

  - *UnabhaÌˆngige* **Verarbeitungseinheiten** (Functional Units) 

  - **RuÌˆckordnungseinheit** (Retire Unit)

  - **Register**: 
    - Allzweckregister

    - Multimediaregister 
    - Spezialregister

  *(Anmerkung: Die Bezeichnungen der Einheiten sind bei den verschiedenen Prozessoren nicht einheitlich!)*



## Dynamische Pipelines

|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| <img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-28%2013.16.50.png" alt="æˆªå±2020-06-28 13.16.50" style="zoom:80%;" /> | <img src="https://github.com/EckoTan0804/upic-repo/blob/master/uPic/æˆªå±2020-06-28 13.17.10.png?raw=true" alt="æˆªå±2020-06-28 13.17.10.png" style="zoom:80%;" /> |

- **1.In-order-Abschnitt**

  - Befehle werden **entsprechend ihrer Programmordnung ("in-order")** bearbeitet
  - Umfasst
    - die Befehlsholphase (IF)

    - die Dekodierphase (ID)

    - die Zuordnungsstufe (Dispatch)
      - *Dynamische* Zuordnung der Befehle an die AusfuÌˆhrungseinheiten
      - Scheduler bestimmt die Anzahl der Befehle, die im naÌˆchsten Takt zugeordnet werden koÌˆnnen

- **Out-of-order-Abschnitt** 

  - AusfuÌˆhrungsphase

- **2.In-order-Abschnitt**

  - GuÌˆltigmachen der Ergebnisse **entsprechend der urspruÌˆnglichen Programmordnung (Retire)**

  - Erhalten der *korrekten* Programmsemantik 
    - Ausnahmeverarbeitung (precise interrupts) 
    - Spekulation

### Befehlsholphase (IF Phase)

- **Befehlsbereitstellung**

  - Holen mehrerer Befehle aus dem Befehls-Cache in den Befehlsholpuffer

    - Anzahl der Befehle, die geholt werden, entspricht typischer Weise der Zuordnungsbandbreite

    - Welche Befehle geholt werden haÌˆngt von der Sprungvorhersage ab

- **Verzweigungseinheit**

  - **UÌˆberwacht** die AusfuÌˆhrung von Verzweigungen, Sprungbefehlen

  - **Spekulatives** Holen von Befehlen

    - Spekulation uÌˆber weiteren Programmverlauf wird von dynamischen Sprungvorhersagetechnik entschieden

    - Verwendung der Vorgeschichte von SpruÌˆngen

    - GewaÌˆhrleistet im Falle einer Fehlspekulation die AbaÌˆnderung der Tabellen sowie das RuÌˆckrollen der faÌˆlschlicherweise ausgefuÌˆhrten Befehle

- **Befehlsholpuffer**

  - entkoppelt die IF Phase von der ID Phase

#### **Sprungvorhersage**

> Siehe auch: [Branch Prediction](https://en.wikipedia.org/wiki/Branch_predictor)

Vorhersage des Verhaltens bei Verzweigungen

- Beim Auftreten einer Verzweigung: Vorhersage des Sprungziels
- FuÌˆllen der VerzoÌˆgerungsphasen spekulativ mit Befehlen, die dem Sprung folgen oder die am Sprungziel stehen
- Nach Auswertung der Sprungbedingung:
  - **Fortfahren** mit der AusfuÌˆhrung ohne VerzoÌˆgerung bei **korrekter Vorhersage**. 
  - **Verwerfen** der geholten Befehle bei **falscher Vorhersage**

Typ:

- **Statische** Sprungvorhersage

  - Die Richtung der Vorhersage ist fuÌˆr einen Befehl **immer gleich** 
    - Alway Taken (T), or
    - Always Not Taken (NT)
  - FuÌˆr superskalare Prozessorarchitekturen zu unflexibel und nicht geeignet ğŸ¤ª

- **Dynamische** Sprungvorhersage

  - Die Verzweigungsrichtung haÌˆngt von der *Vorgeschichte* der Verzweigung ab 

  - BeruÌˆcksichtigung des Programmverhaltens

  - Genaue Vorhersagen moÌˆglich ğŸ‘

  - Hoher Hardware-Aufwand! ğŸ¤ª

  - Detail:	

    â€‹	<img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-29%2011.16.13.png" alt="æˆªå±2020-06-29 11.16.13" style="zoom:80%;" />

    - **Sprungziel-Cache: Branch Target Address Cache (BTAC), Branch Target Buffer (BTB)**

      - Speichert die Adresse der Verzweigung und das entsprechende Sprungziel

    - **Sprungverlaufstabelle, Branch History Table (BHT)**

      - **PraÌˆdiktoren**: Festhalten des Verhaltens der Sprungbefehle waÌˆhrend der AusfuÌˆhrung des Programms

      - Vorhersage des Verhaltens eines geholten Sprungbefehls

      - **Vorhersagebit**

        - Ein-Bit Predictor

          - Wenn das Bit gesetzt ist, wird angenommen, dass der Sprung ausgefuÌˆhrt wird.

          - Bei einer Fehlannahme: *Invertieren* des Bits

            <img src="https://github.com/EckoTan0804/upic-repo/blob/master/uPic/æˆªå±2020-06-29 11.18.31.png?raw=true" alt="æˆªå±2020-06-29 11.18.31.png" style="zoom:80%;" />

        - Zwei-Bit Predictor

          - 2 Bit $\rightarrow$ 4 ZustÃ¤nde

            - Sicher genommen (stronly taken)
            - Vielleicht genommen (weakly taken) 
            - Vielleicht nicht genommen (weakly not taken) 
            - Sicher nicht genommen (stronly not taken)

          - In einem sicheren Zustand sind *zwei* aufeinander folgende Fehlannahmen notwendig, um die Vorhersageannahme umzudrehen.

          - **SaÌˆttigungszaÌˆhler** (Two Bit Predictor with Saturation Scheme)

            - T: Taken
            - NT: Not Taken

            <img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-29 11.30.32.png" alt="æˆªå±2020-06-29 11.30.32" style="zoom:70%;" />

          - **Hysteresemethode** (Two Bit Predictor with Hysteresis Scheme)

            <img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-29%2011.31.34.png" alt="æˆªå±2020-06-29 11.31.34" style="zoom:70%;" />

### Dekodierphase (ID Phase)

- Dekodierung der im Befehlspuffer abgelegten Befehle

  - \#dekodierte Befehle = Befehlsbereitstellungsbandbreite

- Bei CISC-Architekturen (IA-32)

  - Aufteilung der Dekodierung in *mehrere Schritte*
    - Bestimmung der Grenzen der geholten Befehle
    - Dekodierung der Befehle
    - Generierung einer Folge von RISC-aÌˆhnlichen Operationen mit Hilfe dynamischer UÌˆbersetzungstechniken
    - ErmoÌˆglicht effizientes Pipelining und superskalare Verarbeitung

- **Registerumbenennung**

  - *Dynamische* Umbenennung der Operanden- und Ergebnisregister

  - Abbildung: 
    $$
    \text{auÃŸen hin sichtbaren Architekturregister} \rightarrow \text{interne physikalische Register}
    $$

    - Zur Laufzeit wird fuÌˆr jeden Befehl das jeweils spezifizierte Zielregister auf ein *noch nicht belegtes* physikalisches Register abgebildet
    - Nachfolgende Befehle, die dasselbe Architekturregister als Operandenregister verwenden, erhalten das entsprechende physikalische Register
    - Anzahl der Umbenennungsregister kann die Anzahl der Architekturregister uÌˆberschreiten

  - **Konflikten** aufgrund von NamensabhaÌˆngigkeiten

    - **Lese-nach-Schreib-Konflikt (Write-After-Read, WAR)**

      - Befehl $j$ beschreibt sein Zielregister, bevor Befehl $i$ den Operanden gelesen hat.

        (der Befehl $i$ liest einen falschen Wert)

    - **Schreib-nach-Schreib-Konflikt (Write-After-Write, WAW)**

      - Befehl $j$ beschreibt sein Zielregister , bevor Befehl $i$ das Ergebnis geschrieben hat.

        (Der Befehl $i$ liefert den Wert fuÌˆr das Zielregister, anstelle von $j$)

  - **NamensabhaÌˆngigkeiten**

    - Ursachen fÃ¼r Datenkonflikte

    - Treten auf, wenn zwei Instruktionen dasselbe Register dieselbe Speicherzelle (den Namen) verwenden, aber kein Datenfluss zwischen den Befehlen mit dem Namen verbunden ist.

    - zwei Arten von NamensabhaÌˆngigkeiten zwischen zwei Befehlen $i$ und $j$:

      - **GegenabhaÌˆngigkeit (Anti dependence)**

        <img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-29%2013.01.41.png" alt="æˆªå±2020-06-29 13.01.41" style="zoom:80%;" />

      - **AusgabeabhaÌˆngigkeit (Output dependence)**

        <img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-29%2013.07.37.png" alt="æˆªå±2020-06-29 13.07.37" style="zoom:80%;" />

- Schreiben der Befehle in ein Befehlsfenster (instruction window)

  - Befehle sind durch die Sprungvorhersage frei von SteuerflussabhaÌˆngigkeiten ğŸ‘
  - Befehle sind aufgrund der Registerumbenennung frei von NamensabhaÌˆngigkeiten ğŸ‘

### Zuordnungsphase (Dispatch)

- ZufuÌˆhrung der im Befehlsfenster wartenden Befehle zu den AusfuÌˆhrungseinheiten

- Zuordnung bis zur maximalen Zuordnungsbandbreite pro Takt

- Dynamische AufloÌˆsung der Konflikte aufgrund von echten DatenabhaÌˆngigkeiten und Ressourcenkonflikten

  - **Lese-nach-Schreib-Konflikt (Read-After-Write, RAW)**

    - Befehl $j$ liest sein Quellregister , bevor Befehl $i$ das Ergebnis geschrieben hat.

    - Ursache: **Echte DatenabhaÌˆngigkeit (true dependence, flow dependence)**

      - Ein Befehl $j$ ist datenabhaÌˆngig von einem Befehl $i$, wenn eine der folgenden Bedingungen gilt:

        - Befehl $i$ produziert ein Ergebnis, das von Befehl $j$ verwendet wird, oder

        - Befehl $j$ ist datenabhaÌˆngig von Befehl $k$ und Befehl $k$ ist datenabhaÌˆngig von Befehl $i$ (AbhaÌˆngigkeitskette)

      - Bsp:

        <img src="https://raw.githubusercontent.com/EckoTan0804/upic-repo/master/uPic/æˆªå±2020-06-29%2014.29.25.png" alt="æˆªå±2020-06-29 14.29.25" style="zoom:80%;" />

- **Umordnungspuffer (Reservierungstabellen, reservation stations)**

  - Liegen *VOR* den Verarbeitungseinheiten
  - Jede AusfuÌˆhrungseinheit hat seinen eigenen Umordnungspuffer oder mehrere AusfuÌˆhrungseinheiten teilen sich einen Umordnungspuffer
  - Zuordnung eines Befehls an Umordnungspuffer kann nur erfolgen, wenn ein freier Platz vorhanden ist, ansonsten muÌˆssen die nachfolgenden Befehle warten (AufloÌˆsen von Ressourcenkonflikten)

- **RuÌˆckordnungspuffer (reorder buffer)**

  - *Festhalten der urspruÌˆnglichen Befehlsanordnung* ğŸ’ª
  - Eintragen der Befehle, die die Dekodierphase verlassen und in das Befehlsfenster eingetragen werden
  - WaÌˆhrend der folgenden Phasen, die ein Befehl zu durchlaufen hat, wird dessen jeweiliger AusfuÌˆhrungsstand protokolliert.

### BefehlsausfuÌˆhrung (Execution)

- AusfuÌˆhrung der im Opcode spezifizierten Operation und Speichern des Ergebnisses im Zielregister (Umbenennungsregister)

- *Ein*zyklusoperationen

  - AusfuÌˆhrung benoÌˆtigt *einen* Taktzyklus

- *Mehr*zyklusoperationen

  - AusfuÌˆhrung einer Operation auf einer AusfuÌˆhrungseinheit kann *mehrere* Zyklen dauern

  - AusfuÌˆhrungs-Pipeline, arithmetische Pipeline

### Completion

- Eine Instruktion beendet ihre AusfuÌˆhrung, wenn das Ergebnis fuÌˆr nachfolgende Befehle bereitsteht (Forwarding, Puffer)

- **Completion** heiÃŸt: eine BefehlsausfuÌˆhrung ist â€vollstaÌˆndigâ€œ 

  - Erfolgt *unabhaÌˆngig von* der Programmordnung!

- Bereinigung der Reservierungstabellen

- Aktualisierung des Zustands des RuÌˆckordnungspuffers (Reorder Buffer)

  - Es kann eine Unterbrechung angezeigt sein.

  - Es kann ein vollstaÌˆndiger Befehl angezeigt werden, der von einer Spekulation abhaÌˆngt.

### RuÌˆckordnungsstufe (Retire)

- **Commitment**:

  - Nach der VervollstaÌˆndigung beenden die Befehle ihre Bearbeitung (Commitment), d.h. die Befehlsresultate werden in der Programmreihenfolge *guÌˆltig* gemacht

  - Ergebnisse werden in den Architekturregistern dauerhaft gemacht, d.h. aus den internen Umbenennungsregistern (Schattenregistern) zuruÌˆck geschrieben.

- **Bedingungen** fuÌˆr Commitment:

  - Die BefehlsausfuÌˆhrung ist *vollstaÌˆndig*
  - Alle Befehle, die in der Programmordnung vor dem Befehl stehen, haben bereits ihre Bearbeitung beendet oder beenden ihre Bearbeitung im selben Takt.
  - Der Befehl haÌˆngt von KEINer Spekulation ab.

  - KEINe Unterbrechung ist vor oder waÌˆhrend der AusfuÌˆhrung aufgetreten

- Forderung: **Precise Interrupts** bei Auftreten einer Unterbrechung

  - Alle Resultate von Befehlen, die in der Programmreihenfolge *vor* dem Ereignis

    stehen, werden *guÌˆltig* gemacht

  - Die Resultate aller nachfolgenden Befehle werden *verworfen*

  - Das Ergebnis des verursachenden Befehls wird in AbhaÌˆngigkeit der Architektur oder der Art der Unterbrechung guÌˆltig gemacht oder verworfen, ohne weitere Auswirkungen zu haben